# Computational Prime Number Framework Proofs

## Introduction

This article describes several mathematical proofs using a conceptual framework called the "Computational Prime Number Framework" at three levels of detail.

This article is the least detailed (Level 1).

The purpose of this article is to demonstrate how simple yet unconventional definitions can lead to interesting mathematical insights.

**This article doesn't claim to have proven longstanding conjectures within the conventional number theory. The proof is only valid within framework.**

## Why this Argument is Likely to Be Rejected by Mathematicians

This argument does not rely on conventional definitions of prime numbers and does not use a "rigorous" mathematical proof structure. Instead, it relies more on demonstration and simple logic.

## Sieve

```python
def sieve(P, N):
    """
    Filters out numbers from N (natural numbers) that are divisible by any element in P (primes).

    Parameters:
      P (list): Known primes.
      N (list): List of numbers to filter (starting with numbers > 1).

    Returns:
      list: Numbers from N that are not divisible by any element in P.
    """
    return [n for n in N if all(n % p != 0 for p in P)]

print(sieve([2], [n for n in range(2, 40)]))
# [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39]

print(sieve([2,3], [n for n in range(2, 40)]))
# [5, 7, 11, 13, 17, 19, 23, 25, 29, 31, 35, 37]
```

## Sifting Process

```python
def recursive_sifting(P, N):
    """
    Recursively applies the sieve function to generate primes.

    Parameters:
      P (list): Known primes.
      N (list): List of natural numbers (starting with numbers > 1) (assumed infinite conceptually).

    Returns:
      list: An infinite conceptual sequence of primes (limited by recursion depth in practice).
    """
    N = sieve(P, N)
    if not N:
        return P

    # Add the smallest filtered number as the next prime
    next_prime = N[0]
    P.append(next_prime)
    return recursive_sifting(P, N)

# Example usage:
print(recursive_sifting([], [n for n in range(2, 50)]))
# [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
```

## Definition of Prime

Primes in our framework are defined as numbers resulting from a sieve like the one above.

If we have a finite set P, then our primes will not only be P themselves but also include numbers that are not multiples of any element in P.

```python
# Example primes resulting from P = [2]
print(sieve([2], [n for n in range(2, 40)]))
# [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39]
```

Essentially, they are the "holes" in the sieve.

However, if we iteratively update the sieve by adding the first element from the result to P, we will obtain exactly the set of prime numbers.

```python
# Example usage:
print(recursive_sifting([], [n for n in range(2,50)]))
# [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
```

## Euclid's Proof

The original proof states that for any finite set of primes, one can construct a number that is not divisible by any of them, thus contradicting the assumption of finiteness.

Here, we assert that every step of the sifting process is guaranteed to have an infinite candidate list, and we can always select the first number from that list. Thus, we will always keep adding new numbers to our resulting set, thereby proving that there are an infinite number of such numbers.

```python
# NOT EXECUTABLE
# Euclid's Proof

# Inductive step 1
sieve([2], [n for n in range(2, float('inf'))])
# [3, 5, 7, 9, 11, ...]

# Inductive step 2
sieve([2, 3], [n for n in range(2, float('inf'))])
# [5, 7, 9, 11, ...]

# Assume there is a number k (resulting from sieve) that will not generate any further candidates.

# Inductive step k
sieve([2,3,5,7...,k], [n for n in range(2, float('inf'))])
# [5*7*11*...*k+1, 5*7*11*...*k*2+1, ...,5*7*11*...*k*n+1]

# Since k continues to generate infinitely many candidates that contradicted our assumption, we conclude that an infinite number of primes must exist.
```

Thus, we are guaranteed to have an infinite number of primes through this process.

## Twin Primes Proof

The twin prime conjecture asserts that there are infinitely many pairs of primes that differ by 2.

In our framework, "twin prime candidates" are generated by the following sieve:

```python
# NOT EXECUTABLE
sieve([2,3], N)
# [5, 7, 11, 13, 17, 19, 23, 25, 29, 31, 35, 37]
```

They can be generalized as `S({2, 3}) = {2, 3, 6n Â± 1}`.

Every further step in the iteration will remove some of the numbers, and none of the removed numbers will remain. However, the candidates that remain are the twin primes.

Here, we construct a sieve similar to the original, but instead of sieving the numbers themselves, we sieve the indices of twin prime candidates.

```python
sieve([2,3], N)
# [5, 7, 11, 13, 17, 19, 23, 25, 29, 31, 35, 37]

# n = 1 => (6*1-1, 6*1+1) => (5,7)
# n = 2 => (6*2-1, 6*2+1) => (11,13)
# ...
# n = 5 => (6*5-1, 6*5+1) => (29,31)
```

```python
def twin_sieve(P, N):
    """
    Filters the list N for twin prime candidates based on divisibility tests.
    NOTE: We don't consider 2 and 3 because those numbers themselves were used to create a sieve that  generated the twin prime candidates (6n-1, 6n+1)

    Parameters:
      P (list): A list of indices representing previously identified prime-related values.
      N (list): A list of natural numbers.

    Returns:
      list: A filtered list of numbers where both (6n-1) and (6n+1) pass the divisibility tests.
    """
    return list(filter(
        lambda n: all(
            (6*n + 1) % (6*p + 1) != 0 and
            (6*n + 1) % (6*p - 1) != 0 and
            (6*n - 1) % (6*p + 1) != 0 and
            (6*n - 1) % (6*p - 1) != 0
            for p in range(1, P[-1]+1) # to make sure we remove all composite numbers and prime numbers up to and including the 6*p+1
        ),
        N
    ))

# Example usage

## Step 1
candidates = twin_sieve([1], range(1, 50))
print("Twin prime candidate indices:", candidates)
print("Twin prime candidates:", [(6*c-1, 6*c+1) for c in candidates])

## Step 2
candidates = twin_sieve([1,2], range(1, 50))
print("Twin prime candidate indices:", candidates)
print("Twin prime candidates:", [(6*c-1, 6*c+1) for c in candidates])
```

## Twin Sifting Process

```python
def generate_pairs_from_indices(indices):
    return [(6*n-1, 6*n+1) for n in indices]

print(generate_pairs_from_indices([1,2,3,5,7,10]))
```

```python
def twin_recursive_sifting(P, N):
    result = twin_sieve(P, N)
    if not result:
        return P
    return twin_recursive_sifting(P + [result[0]], N)

print(generate_pairs_from_indices(twin_recursive_sifting([1], list(range(1,50))))
```

```python
# NOT EXECUTABLE
# Twin Primes Proof

# Inductive step 1
twin_sieve([1], list(range(1, float('inf'))))
# [2, 3, 5, 7, 10, ...]

# Inductive step 2
sieve([2, 3], list(range(1, float('inf'))))
# [3, 5, 7, 10, ...]

# Assume there exists a number k (resulting from sieve) that does not generate any further candidates.

# Inductive step k
# Utility function
def get_index(candidate):
    return (candidate-1)//6

sieve([2,3,5,7...,k], list(range(1, float('inf'))))
# [get_index(6*(5*7*11*...*k)+1), get_index(6*(5*7*11*...*k*2)+1), ..., get_index(6*(5*7*11*...*k*n)+1)]

# Since k will generate infinitely many candidates, we can always construct infinitely many indivisible examples.
```

## Conclusion

This argument is based on a non-conventional definition of primes as resulting from the recursive sifting process. The proof demonstrates that by using the sifting process, we always guarantee that we will obtain the next pair at every step, thus proving that there will be infinitely many twin prime pairs.

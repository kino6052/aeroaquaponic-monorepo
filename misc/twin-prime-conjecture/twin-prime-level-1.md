# Computation Prime Number Framework Proofs

## Introduction

This article describes several mathematical proofs using a conceptual framework called "Computational Prime Number Framework" in three levels of detail.

This article is the least detailed (level 1).

The reason for this article is to demonstrate how simple yet unconventional definitions may lead to interesting mathematical insights.

## Why this argument is likely to be rejected by mathematicians

This argument doesn't rely on conventional definitions of prime numbers and doesn't use "rigourous" mathematical proof structure. It relies more on demonstration and simple logic.

## Sieve

```python
def sieve(P, N):
    """
    Filters out numbers from N (natural numbers) that are divisible by any element in P (primes)

    Parameters:
      P (list): Known primes.
      N (list): List of numbers to filter (starting with numbers > 1).

    Returns:
      list: Numbers from N not divisible by any element in P.
    """
    return [n for n in N if all(n % p != 0 for p in P)]

    print(sieve([2], [n for n in range(2, 40)]))
    # [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39]

    print(sieve([2,3], [n for n in range(2,40)]))
    # [5, 7, 11, 13, 17, 19, 23, 25, 29, 31, 35, 37]
```

## Sifting Process

```python
def recursive_sifting(P, N):
    """
    Recursively applies the sieve function to generate primes.

    Parameters:
      P (list): Known primes.
      N (list): List of natural numbers (starting with numbers > 1) (assumed infinite conceptually).

    Returns:
      list: Infinite conceptual sequence of primes (limited by recursion depth in practice).
    """
    N = sieve(P, N)
    if not N:
        return P

    # Add the smallest filtered number as the next prime
    next_prime = N[0]
    P.append(next_prime)
    return recursive_sifting(P, N)

# Example usage:
print(recursive_sifting([], [n for n in range(2,50)]))
# [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
```

## Definition of Prime

Primes in our framework are defined as number resulting from a sieve like above.

If we have a finite set of P, the our primes will not only be P themselves but also multiples of each of them.

```python
# Example primes resulting from P = [2]
print(sieve([2], [n for n in range(2, 40)]))
    # [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39]
```

Essentially they are holes in the sieve.

However, if we want to create an iterative sieve that would keep adding first element from the result to P, we would get a set that is exactly the set of prime numbers.

```python
# Example usage:
print(recursive_sifting([], [n for n in range(2,50)]))
# [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
```

## Euclid's Proof

The original proof - for any finite set of primes, once can construct a number that is not divisible by any of them, thus contradicting the finitude assumption.

Here we assert that every step of the sifting process is guaranteed to have an infinte candidate list and we can always select the first number from that list, thus we will always keep adding new number to our resulting set and thus proving that there are infinite amount of such numbers.

```python
# Euclid's Proof

# inductive step 1
sieve([2], [n for n in range(2, float('inf'))])
# [3, 5, 7, 9, 11, ...]

# inductive step 2
sieve([2, 3], [n for n in range(2, float('inf'))])
# [5, 7, 9, 11, ...]

# let's assume there is a number k (resulting from sieve), that will not generate any further candidates

# inductive step k
sieve([2,3,5,7...,k], [n for n in range(2, float('inf'))])
# [5*7*11*...*k+1, 5*7*11*...*k*2+1, ...,5*7*11*...*k*n+1]

# we see that we know that k will generate infinitely many candidates as we can construct infinitely many indivisible examples)
```

Thus we are guaranteed to have an infinite number of primes from such a process.

## Twin Primes Proof

TThe twin prime conjecture asserts that there are infinitely many pairs of primes that differ by 2.

In our framework "twin prime candidates" are generated by the following sieve:

```python
sieve([2,3], N)
# [5, 7, 11, 13, 17, 19, 23, 25, 29, 31, 35, 37]
```

They can be generalized as `S({2, 3}) = { 2, 3, 6n Â± 1 }`

Every further step in iteration will remove some of the numbers and none of them will remain, but those candidates that remain are the twin primes.

Here we construct a sieve similar to the original, but it will sieve not the numbers themselves, but indices of twin prime candidates

```python
sieve([2,3], N)
# [5, 7, 11, 13, 17, 19, 23, 25, 29, 31, 35, 37]

# n = 1 => (6*1-1, 6*1+1) => (5,7)
# n = 2 => (6*2-1, 6*2+1) => (11,13)
# ...
# n = 5 => (6*5-1, 6*5+1) => (29,31)
```

```python
def twin_sieve(P, N):
    """
    Filters the list N for twin prime candidates based on divisibility tests.

    Parameters:
      P (list): A list of indices representing previously identified prime-related values.
      N (list): P list of natural numbers.

    Returns:
      list: A filtered list of numbers where both (6n-1) and (6n+1) pass the divisibility tests.
    """
    return list(filter(
        lambda n: all(
            (6*n + 1) % (6*p + 1) != 0 and
            (6*n + 1) % (6*p - 1) != 0 and
            (6*n - 1) % (6*p + 1) != 0 and
            (6*n - 1) % (6*p - 1) != 0
            for p in range(1, P[-1]+1) # to make sure we remove all prime candidates
        ),
        N
    ))

# Example usage

## Step 1
candidates = twin_sieve([1], range(1, 50))
print("Twin prime candidate indices", candidates)
# Twin prime candidates: [2, 3, 5, 7, 10, 12, 17, 18, 23, 25, 28, 30, 32, 33, 35, 37, 38, 40, 42, 45, 47]
print("Twin prime candidates", [(6*c-1, 6*c+1) for c in candidates])
# Twin prime candidates [(11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73), (101, 103), (107, 109), (137, 139), (149, 151), (167, 169), (179, 181), (191, 193), (197, 199), (209, 211), (221, 223), (227, 229), (239, 241), (251, 253), (269, 271), (281, 283)]

## Step 2
candidates = twin_sieve([1,2], range(1, 50))
print("Twin prime candidate indices", candidates)
# Twin prime candidate indices [3, 5, 7, 10, 12, 17, 18, 23, 25, 30, 32, 33, 38, 40, 45, 47]
print("Twin prime candidates", [(6*c-1, 6*c+1) for c in candidates])
# Twin prime candidates [(17, 19), (29, 31), (41, 43), (59, 61), (71, 73), (101, 103), (107, 109), (137, 139), (149, 151), (179, 181), (191, 193), (197, 199), (227, 229), (239, 241), (269, 271), (281, 283)]
```

## Twin Sifting Process

```python
def generate_pairs_from_indices(indices):
    return [(6*n-1, 6*n+1) for n in indices]

print(generate_pairs_from_indices([1,2,3,5,7,10]))
```

```python
def twin_recursive_sifting(P, N):
    result = twin_sieve(P, N)
    if len(result) == 0:
        return P
    return twin_recursive_sifting(P + [result[0]], N)

print(generate_pairs_from_indices(twin_recursive_sifting([1], [n for n in range(1,50)])))
# [(5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73), (101, 103), (107, 109), (137, 139), (149, 151), (179, 181), (191, 193), (197, 199), (227, 229), (239, 241), (269, 271), (281, 283)]
```

```python
# Twin Primes Proof

# inductive step 1
twin_sieve([1], [n for n in range(1, float('inf'))])
# [2, 3, 5, 7, 10, ...]

# inductive step 2
sieve([2, 3], [n for n in range(1, float('inf'))])
# [3, 5, 7, 10, ...]

# let's assume there is a number k (resulting from sieve), that will not generate any further candidates

# inductive step k
# utility
def getIndex(candidate):
  return (candidate-1)/6

sieve([2,3,5,7...,k], [n for n in range(1, float('inf'))])
# [getIndex(6*(5*7*11*...*k)+1), getIndex(6*(5*7*11*...*k*2)+1), ...,getIndex(6*(5*7*11*...*k*n)+1)]

# we see that we know that k will generate infinitely many candidates as we can construct infinitely many indivisible examples)
```
